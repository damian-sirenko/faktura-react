require("dotenv").config();
const express = require("express");
const cors = require("cors");
const cookieParser = require("cookie-parser");
const fs = require("fs");
const path = require("path");
const invoicesRepo = require("./server/repos/invoicesRepo.js");

// —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É—î–º–æ MySQL –ø—É–ª –ø—ñ–¥ —á–∞—Å —Å—Ç–∞—Ä—Ç—É —Å–µ—Ä–≤–µ—Ä–∞
const { initDB } = require("./server/db.js");

const analyticsRouter = require("./routes/analytics");
const { createProtocolPDF, createProtocolZip } = require("./protocol.pdf.js");

const { generateEPPBuffer, to2 } = require("./epp.js");

// –≥–µ–Ω–µ—Ä–∞—Ü—ñ—è PDF-—Ñ–∞–∫—Ç—É—Ä
const { generateInvoicePDF } = require("./invoice.pdfkit.cjs");

/* ===== üîΩ –î–û–î–ê–ù–û –¥–ª—è PDF-—Å–ø–∏—Å–∫—É —ñ–Ω–≤–æ–π—Å—ñ–≤ ===== */
const PDFDocument = require("pdfkit");
const dayjs = require("dayjs");
const { createClientsKartotekaPDF } = require("./clients.kartoteka.pdf.js");
const clientsRepo = require("./server/repos/clientsRepo.js");
// –¥–æ—Å—Ç—É–ø –¥–æ MySQL (—Ç–æ–π —Å–∞–º–∏–π pool, —è–∫–∏–π —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É—î—Ç—å—Å—è –≤ server/db.js)
const { query: sql } = require("./server/db.js");
const { pool } = require("./server/db.js");
const settingsRepo = require("./server/repos/settingsRepo.js");

const { authRequired } = require("./backend/middleware/auth");

const explicitAllow = new Set([
  "http://localhost:5174",
  "http://127.0.0.1:5173",
  "http://127.0.0.1:5174",
  "http://localhost:3000",
  "http://127.0.0.1:3000",
  "https://panel.sterylserwis.pl",
  "https://sterylserwis.pl",
  "https://www.sterylserwis.pl",
]);

function isPrivateHost(hostname) {
  return (
    /^localhost$|^127\.0\.0\.1$|^0\.0\.0\.0$/.test(hostname) ||
    /^10\.\d+\.\d+\.\d+$/.test(hostname) ||
    /^192\.168\.\d+\.\d+$/.test(hostname) ||
    /^172\.(1[6-9]|2\d|3[0-1])\.\d+\.\d+$/.test(hostname)
  );
}

const DEV = process.env.NODE_ENV !== "production";

// DEV-–±–µ–∑–ø–µ–∫–∞: –ª–æ–∫–∞–ª—å–Ω–æ –Ω–µ –≤–∏–º–∞–≥–∞—î–º–æ —Ç–æ–∫–µ–Ω (–∞–±–æ —è–∫—â–æ AUTH_DISABLE_DEV=1)
const protect = (req, res, next) => {
  if (DEV || process.env.AUTH_DISABLE_DEV === "1") return next();
  return authRequired(req, res, next);
};

const app = express();

app.set("trust proxy", 1);

app.use(
  cors({
    origin(origin, callback) {
      if (!origin) return callback(null, true);
      if (explicitAllow.has(origin)) return callback(null, true);
      try {
        const { hostname } = new URL(origin);
        if (DEV && isPrivateHost(hostname)) return callback(null, true);
      } catch {}
      return callback(null, false);
    },
    credentials: true,
    methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
    allowedHeaders: [
      "Content-Type",
      "Authorization",
      "X-CSRF-Token",
      "x-update-status-only",
      "x-allow-renumber",
      "x-confirm-action",
    ],
  })
);

const cookieSecure = !!process.env.COOKIE_SECURE; // true –Ω–∞ HTTPS, false –ª–æ–∫–∞–ª—å–Ω–æ
const cookieSameSite = cookieSecure ? "none" : "lax";

app.use(cookieParser());
app.use(express.json({ limit: process.env.JSON_LIMIT || "25mb" }));

// [–ê–ù–ö–û–†] // ‚¨áÔ∏é –≤—Å—Ç–∞–≤–∏—Ç–∏ –≤—ñ–¥—Ä–∞–∑—É –ø—ñ—Å–ª—è —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è app = express() —Ç–∞ –±–∞–∑–æ–≤–∏—Ö app.use(...)
app.use((req, res, next) => {
  // –î–æ–∑–≤–æ–ª—è—î–º–æ —Ç–æ–∫–µ–Ω —É query, –Ω–∞–ø—Ä. ?bearer=JWT
  if (!req.headers.authorization && req.query && req.query.bearer) {
    req.headers.authorization = `Bearer ${req.query.bearer}`;
  }
  next();
});

process.on("unhandledRejection", (e) => {
  console.error("‚ùå UnhandledRejection:", e);
});
process.on("uncaughtException", (e) => {
  console.error("‚ùå UncaughtException:", e);
});

/* -----------------------------
 * –®–ª—è—Ö–æ–≤—ñ –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∏
 * ----------------------------- */
const ROOT = __dirname;
const DATA_DIR = path.join(ROOT, "data");
const GENERATED_DIR = path.join(ROOT, "generated");
const SIGNATURES_DIR = path.join(ROOT, "signatures");

// === ‚ûï –î–û–î–ê–ù–û: –ø–æ—à—É–∫ —ñ –ø—É–±–ª—ñ—á–Ω–∏–π —à–ª—è—Ö –¥–æ "—Å—Ç–∞—Ç–∏—á–Ω–æ–≥–æ –ø—ñ–¥–ø–∏—Å—É –ø—Ä–∞—Ü—ñ–≤–Ω–∏–∫–∞" ===
function resolveStaffSignFile() {
  const candidates = [
    // –±–µ–∫–µ–Ω–¥ /assets
    path.join(ROOT, "assets", "staff-sign.png"),
    path.join(ROOT, "assets", "staff-sign.jpg"),
    // —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥ src/assets
    path.join(process.cwd(), "src", "assets", "staff-sign.png"),
    path.join(process.cwd(), "src", "assets", "staff-sign.jpg"),
    // –∫–æ—Ä—ñ–Ω—å –ø—Ä–æ–µ–∫—Ç—É
    path.join(process.cwd(), "assets", "staff-sign.png"),
    path.join(process.cwd(), "assets", "staff-sign.jpg"),
    // –æ–¥–∏–Ω —Ä—ñ–≤–µ–Ω—å –≤–≥–æ—Ä—É
    path.join(process.cwd(), "..", "src", "assets", "staff-sign.png"),
    path.join(process.cwd(), "..", "src", "assets", "staff-sign.jpg"),
  ];
  for (const p of candidates) {
    if (fs.existsSync(p)) return p;
  }
  return null;
}
function ensureStaticStaffSigPublic() {
  const src = resolveStaffSignFile();
  const staticDir = path.join(SIGNATURES_DIR, "_static");
  if (!fs.existsSync(staticDir)) fs.mkdirSync(staticDir, { recursive: true });

  // —è–∫—â–æ –Ω–µ–º–∞—î —Ñ–∞–π–ª—É ‚Äî —Å—Ç–≤–æ—Ä–∏–º–æ –ø—Ä–æ—Å—Ç—É ¬´–ø–æ—Ä–æ–∂–Ω—é¬ª png, —â–æ–± –µ–Ω–¥–ø–æ—ñ–Ω—Ç –Ω–µ –ø–∞–¥–∞–≤
  const target = path.join(staticDir, "staff-sign.png");
  if (!src) {
    try {
      // 1x1 –ø—Ä–æ–∑–æ—Ä–∏–π PNG
      const blank =
        "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=";
      fs.writeFileSync(target, Buffer.from(blank, "base64"));
    } catch {}
    return "/signatures/_static/staff-sign.png";
  }

  try {
    fs.copyFileSync(src, target);
  } catch {}
  return "/signatures/_static/staff-sign.png";
}
let DEFAULT_STAFF_SIG_PUBLIC = ensureStaticStaffSigPublic();

/* -----------------------------
 * CORS —ñ –ø–∞—Ä—Å–µ—Ä–∏
 * ----------------------------- */

explicitAllow.add("https://panel.sterylserwis.pl");
explicitAllow.add("https://sterylserwis.pl");
explicitAllow.add("https://www.sterylserwis.pl");

app.use("/auth", require("./routes/auth"));

// ‚õîÔ∏è –∑–∞—Ö–∏—â–∞—î–º–æ –æ—Å–Ω–æ–≤–Ω—ñ API-–ø—Ä–µ—Ñ—ñ–∫—Å–∏ (–∫—Ä—ñ–º /auth, __health —Ç–∞ —Å—Ç–∞—Ç–∏–∫—ñ–≤)
app.use("/clients", protect);
app.use("/invoices", protect);
app.use("/upload", protect);
app.use("/gen", protect);
app.use("/psl", protect);
app.use("/settings", protect);
app.use("/protocols", protect);
app.use("/sign-queue", protect);
app.use("/export-epp", protect);
app.use("/download-multiple", protect);

// server.js ‚Äî confirm-–≥–∞—Ä–¥ –¥–ª—è –Ω–µ–±–µ–∑–ø–µ—á–Ω–∏—Ö –¥—ñ–π
function requireConfirmHeader(actionId) {
  return (req, res, next) => {
    const h = String(req.headers["x-confirm-action"] || "");
    const q = String(req.query.confirm || "");
    if (h === actionId || q === actionId) return next();
    return res.status(409).json({
      error: "Confirm header required",
      need: actionId,
      how: `add header: x-confirm-action: ${actionId}`,
    });
  };
}

// ===== Services =====
app.get("/services", async (req, res) => {
  try {
    const rows = await sql(`
      SELECT name, price_gross, vat_rate
      FROM services
      ORDER BY name
    `);
    res.json(
      rows.map((r) => ({
        name: r.name,
        price_gross: Number(r.price_gross || 0),
        vat_rate: Number(r.vat_rate || 23),
      }))
    );
  } catch (e) {
    console.error("GET /services", e);
    res.status(500).json({ error: String(e.message) });
  }
});

// health/config for frontend
app.get("/__services", (_req, res) => {
  res.json({ ok: true, name: "backend", version: 1 });
});

app.use("/analytics", analyticsRouter);

// server.js ‚Äî –≤—Å—Ç–∞–≤–∏—Ç–∏ –Ω–∏–∂—á–µ –±—É–¥—å-—è–∫–∏—Ö app.get(...) –¥—ñ–∞–≥–Ω–æ—Å—Ç–∏—á–Ω–∏—Ö –º–∞—Ä—à—Ä—É—Ç—ñ–≤, –¥–æ "–°–¢–ê–¢–ò–ö–ê"
app.get("/favicon.ico", (_req, res) => res.status(204).end());
app.get("/site.webmanifest", (_req, res) => res.status(204).end());
app.get("/manifest.webmanifest", (_req, res) => res.status(204).end());

app.get("/__health", (_req, res) =>
  res.json({ ok: true, time: new Date().toISOString() })
);
// –≥–ª—É—à–∏–ª–∫–∞ –¥–ª—è –∑–∞–ø–∏—Ç—É Chrome DevTools
app.get("/.well-known/appspecific/com.chrome.devtools.json", (_req, res) => {
  // –Ω—ñ—á–æ–≥–æ –Ω–µ –≤—ñ–¥–¥–∞—î–º–æ, –ø—Ä–æ—Å—Ç–æ 204
  res.status(204).end();
});

// –¥—ñ–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ —ñ–Ω–≤–æ–π—Å—ñ–≤
app.get("/__db/check-invoices", async (_req, res) => {
  try {
    const all = await invoicesRepo.queryAllInvoices();
    res.json({
      count: all.length,
      head: all.slice(0, 5),
    });
  } catch (e) {
    res.status(500).json({ error: String(e.message) });
  }
});

app.use((req, _res, next) => {
  console.log(`[API] ${req.method} ${req.url}`);
  next();
});

/* ===========================
 * –î–æ–ø–æ–º—ñ–∂–Ω—ñ —É—Ç–∏–ª—ñ—Ç–∏
 * =========================== */

function safeSeg(s) {
  return String(s || "")
    .toLowerCase()
    .replace(/[^a-z0-9._-]+/g, "-")
    .replace(/(^-|-$)/g, "");
}

function findGeneratedFileDeep(filename) {
  const safe = path.basename(String(filename || ""));
  const stack = [GENERATED_DIR];
  while (stack.length) {
    const dir = stack.pop();
    if (!fs.existsSync(dir)) continue;
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    for (const e of entries) {
      const full = path.join(dir, e.name);
      if (e.isDirectory()) stack.push(full);
      else if (e.isFile() && e.name === safe) return full;
    }
  }
  return null;
}

function toISO10(v) {
  if (!v) return null;
  if (v instanceof Date && !isNaN(v)) {
    const y = v.getFullYear();
    const m = String(v.getMonth() + 1).padStart(2, "0");
    const d = String(v.getDate()).padStart(2, "0");
    return `${y}-${m}-${d}`;
  }
  const s = String(v);
  const m = s.match(/^(\d{4}-\d{2}-\d{2})/);
  return m ? m[1] : null;
}

/* –î–∞–Ω—ñ –ø—Ä–æ–¥–∞–≤—Ü—è (–¥–ª—è —à–∞–±–ª–æ–Ω—É) */
const SELLER = {
  name: "CORRECT SOLUTION SP. Z O.O.",
  nip: "6751516747",
  address: "Osiedle Dywizjonu 303 62F, 31-875 Krak√≥w",
};

function invoiceToPdfData(inv) {
  const buyer_identifier = inv.buyer_nip
    ? `NIP: ${inv.buyer_nip}`
    : inv.buyer_pesel
    ? `PESEL: ${inv.buyer_pesel}`
    : "";

  const net = inv.net || "";
  const gross = inv.gross || "";
  const vat =
    net && gross
      ? to2(
          Number(String(gross).replace(",", ".")) -
            Number(String(net).replace(",", "."))
        )
      : "";

  return {
    number: inv.number || "",
    place: "",
    issue_date: inv.issueDate || inv.issue_date || "",
    sale_date: inv.issueDate || inv.issue_date || "",
    due_date: inv.dueDate || inv.due_date || "",

    seller_name: SELLER.name,
    seller_address: SELLER.address,
    seller_nip: SELLER.nip,

    buyer_name: inv.client || inv.buyer_name || "",
    buyer_address: inv.buyer_address || inv.address || "",
    buyer_identifier,

    items: Array.isArray(inv.items) ? inv.items : [],

    net_sum: net || "",
    vat_sum: vat || "",
    gross_sum: gross || "",

    amount_due: gross || "",
    amount_in_words: "",
    paid_amount: "",
    payment_method: "",
    bank: "",
    account: "",
    issuer: "Dmytro Sirenko",
  };
}
function mapDbInvoiceRow(row) {
  let items = [];
  try {
    items = JSON.parse(row.items_json || "[]");
  } catch {}
  return {
    number: row.number,
    client: row.clientName,
    issueDate: row.issueDate,
    dueDate: row.dueDate,
    net: row.net,
    gross: row.gross,
    filename: row.filename,
    folder: row.folder,
    items,
    buyer_address: row.buyer_address,
    buyer_nip: row.buyer_nip,
    buyer_pesel: row.buyer_pesel,
    status: row.status,
  };
}

async function ensurePdfForInvoice(inv, { force = true } = {}) {
  if (!inv || !inv.number) return null;

  const folderSafe = inv.folder ? safeSeg(inv.folder) : "";
  const outDir = folderSafe
    ? path.join(GENERATED_DIR, folderSafe)
    : GENERATED_DIR;
  if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });

  const filename =
    inv.filename || `Faktura_${String(inv.number).replaceAll("/", "_")}.pdf`;

  // –Ø–∫—â–æ –≤–∂–µ –¥–µ—Å—å —ñ—Å–Ω—É—î ‚Äî –ø–µ—Ä–µ–∑–∞–ø–∏—Å—É—î–º–æ –π–æ–≥–æ (—â–æ–± –ø–æ—Å–∏–ª–∞–Ω–Ω—è –ª–∏—à–∞–ª–∏—Å—å —Ç–∏–º–∏ –∂)
  const foundExisting = findGeneratedFileDeep(path.basename(filename));
  const outputPath =
    foundExisting || path.join(outDir, path.basename(filename));

  // –ó–∞–≤–∂–¥–∏ –ø–µ—Ä–µ–≥–µ–Ω–µ—Ä–æ–≤—É—î–º–æ –∑ –∞–∫—Ç—É–∞–ª—å–Ω–∏—Ö –¥–∞–Ω–∏—Ö
  const data = invoiceToPdfData(inv);
  await generateInvoicePDF(data, outputPath);

  return outputPath;
}

/* -----------------------------
 * /generated/:filename ‚Äî —Ä–æ–∑—É–º–Ω–∏–π –≤—ñ–¥–¥–∞–≤–∞—á/–≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä PDF —Ñ–∞–∫—Ç—É—Ä
 * (—Å—Ç–∞–≤–∏–º–æ –î–û —Å—Ç–∞—Ç–∏—á–Ω–æ—ó —Ä–æ–∑–¥–∞—á—ñ)
 * ----------------------------- */
app.get("/generated/:filename", protect, async (req, res) => {
  const fn = path.basename(req.params.filename);
  try {
    // 1. —Å–ø—Ä–æ–±–∞ –≤–∏—Ç—è–≥–Ω—É—Ç–∏ —ñ–Ω–≤–æ–π—Å –∑ –ë–î –∑–∞ filename
    const dbRows = await invoicesRepo.queryInvoiceByFilename(fn);
    if (dbRows && dbRows.length) {
      const row = dbRows[0];

      const invLikeOld = {
        number: row.number,
        client: row.clientName,
        issueDate: row.issueDate,
        dueDate: row.dueDate,
        net: row.net,
        gross: row.gross,
        filename: row.filename,
        folder: row.folder,
        items: (() => {
          try {
            return JSON.parse(row.items_json || "[]");
          } catch {
            return [];
          }
        })(),
        buyer_address: row.buyer_address,
        buyer_nip: row.buyer_nip,
        buyer_pesel: row.buyer_pesel,
        status: row.status,
      };

      const p = await ensurePdfForInvoice(invLikeOld, { force: true });
      res.setHeader("Content-Type", "application/pdf");
      res.setHeader("Content-Disposition", `inline; filename="${fn}"`);
      return res.sendFile(p);
    }

    // 2. —è–∫—â–æ –Ω–µ –∑–Ω–∞–π—à–ª–∏ –≤ –ë–î ‚Äî —à—É–∫–∞—î–º–æ —Ñ—ñ–∑–∏—á–Ω–æ
    const p = findGeneratedFileDeep(fn);
    if (p && fs.existsSync(p)) {
      res.setHeader("Content-Type", "application/pdf");
      res.setHeader("Content-Disposition", `inline; filename="${fn}"`);
      return res.sendFile(p);
    }

    return res.status(404).send("Nie znaleziono pliku.");
  } catch (e) {
    console.error("‚ùå /generated error:", e);
    return res.status(500).send("Internal server error");
  }
});

/* ‚úÖ –î–û–î–ê–ù–û: –ø—Ä–µ–≤‚Äô—é/–≤—ñ–¥–¥–∞—á–∞ –¥–ª—è –≤–∫–ª–∞–¥–µ–Ω–∏—Ö –ø–∞–ø–æ–∫ /generated/:folder/:filename */
app.get("/generated/:folder/:filename", protect, async (req, res) => {
  const fn = path.basename(req.params.filename);
  try {
    const dbRows = await invoicesRepo.queryInvoiceByFilename(fn);
    if (dbRows && dbRows.length) {
      const row = dbRows[0];

      const invLikeOld = {
        number: row.number,
        client: row.clientName,
        issueDate: row.issueDate,
        dueDate: row.dueDate,
        net: row.net,
        gross: row.gross,
        filename: row.filename,
        folder: row.folder,
        items: (() => {
          try {
            return JSON.parse(row.items_json || "[]");
          } catch {
            return [];
          }
        })(),
        buyer_address: row.buyer_address,
        buyer_nip: row.buyer_nip,
        buyer_pesel: row.buyer_pesel,
        status: row.status,
      };

      const p = await ensurePdfForInvoice(invLikeOld, { force: true });
      res.setHeader("Content-Type", "application/pdf");
      res.setHeader("Content-Disposition", `inline; filename="${fn}"`);
      return res.sendFile(p);
    }

    const p = findGeneratedFileDeep(fn);
    if (p && fs.existsSync(p)) {
      res.setHeader("Content-Type", "application/pdf");
      res.setHeader("Content-Disposition", `inline; filename="${fn}"`);
      return res.sendFile(p);
    }

    return res.status(404).send("Nie znaleziono pliku.");
  } catch (e) {
    console.error("‚ùå /generated (folder) error:", e);
    return res.status(500).send("Internal server error");
  }
});

/* -----------------------------
 * –°–¢–ê–¢–ò–ö–ê
 * ----------------------------- */
app.use("/signatures", express.static(SIGNATURES_DIR));
app.use("/generated", protect, express.static(GENERATED_DIR));

// üîß –ú–∞—Ä—à—Ä—É—Ç–∏ –¥–ª—è —Å–ø–∏—Å–∫—É —ñ–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ñ–≤ (GET /tools, POST /tools/save)
const mountToolsRoutes = require("./server.tools.routes.cjs");
mountToolsRoutes(app);

const { createInvoiceListPDF } = require("./invoices.list.pdf.js");

const genRouter = require("./routes/generateFromClients");
app.use("/gen", genRouter);

const pslRouter = require("./routes/psl");
app.use("/psl", pslRouter);

/* -----------------------------
 * API: –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è
 * ----------------------------- */
// GET /settings –∑ MySQL
app.get("/settings", async (_req, res) => {
  try {
    const s = await settingsRepo.get();
    res.json(s);
  } catch (e) {
    console.error("settings GET error:", e);
    res.status(500).json({ error: "Failed to load settings from DB" });
  }
});

app.post("/settings", async (req, res) => {
  try {
    const body = req.body || {};
    const next = await settingsRepo.update({
      perPiecePriceGross: body.perPiecePriceGross,
      defaultVat: body.defaultVat,
      courierPriceGross: body.courierPriceGross,
      shippingPriceGross: body.shippingPriceGross,
      currentIssueMonth: body.currentIssueMonth,

      // –Ω–æ–≤—ñ –ø–æ–ª—è:
      dueMode: body.dueMode === "fixed" ? "fixed" : "days",
      dueDays: Number(body.dueDays) || 0,
      dueFixedDate:
        typeof body.dueFixedDate === "string" &&
        /^\d{4}-\d{2}-\d{2}$/.test(body.dueFixedDate)
          ? body.dueFixedDate
          : null,
    });
    res.json({ success: true, settings: next });
  } catch (e) {
    console.error("settings POST error:", e);
    res.status(500).json({ error: "Failed to save settings to DB" });
  }
});

/* -----------------------------
 * API: –ö–ª—ñ—î–Ω—Ç–∏
 * ----------------------------- */
app.post("/save-clients", async (req, res) => {
  const clients = req.body;
  if (!Array.isArray(clients)) {
    return res.status(400).json({ error: "Invalid data format" });
  }
  try {
    const result = await clientsRepo.replaceAllClients(clients);
    res.json({ success: true, inserted: result.inserted });
  } catch (err) {
    console.error("‚ùå Error saving clients into MySQL:", err);
    res.status(500).json({ error: "Failed to save clients into DB" });
  }
});

app.get("/clients", async (_req, res) => {
  try {
    const rows = await clientsRepo.getAllClients(); // <-- —Ç–µ–ø–µ—Ä –í–°–Ü, —ñ archived=1 —Ç–µ–∂
    res.json(rows);
  } catch (err) {
    console.error("‚ùå Error reading clients from MySQL:", err);
    res.status(500).json({ error: "Failed to load clients from DB" });
  }
});
// server.js ‚Äî –∫–∞—Ä—Ç–æ—Ç–µ–∫–∞ –∫–ª—ñ—î–Ω—Ç—ñ–≤ PDF
app.get("/clients/kartoteka.pdf", (req, res) => {
  Promise.resolve(createClientsKartotekaPDF(req, res)).catch((e) => {
    console.error("‚ùå /clients/kartoteka.pdf error:", e);
    if (!res.headersSent) res.status(500).send("PDF generation error");
  });
});

/* -----------------------------
 * API: invoices.json (–º–µ—Ç–∞–¥–∞–Ω—ñ) + download
 * ----------------------------- */
app.get("/invoices", async (_req, res) => {
  try {
    const rows = await invoicesRepo.queryAllInvoices();
    const data = rows.map(mapDbInvoiceRow);
    res.json(data);
  } catch (e) {
    console.error("invoices GET DB error:", e);
    res.status(500).json({ error: "Failed to load invoices from DB" });
  }
});

app.put("/invoices/:number", async (req, res) => {
  try {
    const oldNo = String(req.params.number || "");
    const body = req.body || {};

    // —è–∫—â–æ –ø—Ä–∏–ª–µ—Ç—ñ–≤ —Ç—ñ–ª—å–∫–∏ —Å—Ç–∞—Ç—É—Å ‚Äî –æ–Ω–æ–≤–ª—é—î–º–æ –ª–∏—à–µ –π–æ–≥–æ, –±–µ–∑ —á—ñ–ø–∞–Ω–Ω—è —ñ–Ω—à–∏—Ö –ø–æ–ª—ñ–≤
    const isStatusOnly =
      Object.prototype.hasOwnProperty.call(body, "status") &&
      Object.keys(body).length === 1;

    if (isStatusOnly) {
      const ok = await invoicesRepo.updateStatusByNumber(oldNo, body.status);
      if (!ok) return res.status(404).json({ error: "Invoice not found" });
      return res.json({ success: true, status: body.status });
    }

    const allowRenumber = String(req.headers["x-allow-renumber"] || "") === "1";
    const wantsRenumber =
      allowRenumber &&
      !!body._renumber &&
      body.number &&
      String(body.number) !== oldNo;

    const makeInvLike = (baseNo) => ({
      number: body.number || baseNo,
      client: body.client || body.clientName || "",
      issueDate: body.issueDate || null,
      dueDate: body.dueDate || null,
      net: body.net,
      gross: body.gross,
      filename:
        body.filename ||
        `Faktura_${String(body.number || baseNo).replaceAll("/", "_")}.pdf`,
      folder: body.folder || "",
      items: Array.isArray(body.items) ? body.items : [],
      buyer_address: body.buyer_address || body.address || "",
      buyer_nip: body.buyer_nip || "",
      buyer_pesel: body.buyer_pesel || "",
      status: body.status || "issued",
    });

    if (wantsRenumber) {
      const ok = await invoicesRepo.renumberInvoice(oldNo, body);
      if (!ok) return res.status(404).json({ error: "Invoice not found" });

      const oldFile = String(body.oldFilename || "");
      if (oldFile) {
        const p = findGeneratedFileDeep(path.basename(oldFile));
        if (p && fs.existsSync(p)) {
          try {
            fs.unlinkSync(p);
          } catch {}
        }
      }

      try {
        await ensurePdfForInvoice(makeInvLike(body.number), { force: true });
      } catch {}
      return res.json({ success: true, renumbered: true });
    }

    const ok = await invoicesRepo.updateByNumber(oldNo, body);
    if (!ok) return res.status(404).json({ error: "Invoice not found" });

    try {
      await ensurePdfForInvoice(makeInvLike(oldNo), { force: true });
    } catch {}
    return res.json({ success: true, renumbered: false });
  } catch (e) {
    console.error("PUT /invoices/:number error:", e);
    return res.status(500).json({ error: "Failed to update invoice" });
  }
});

// DELETE invoice by filename (DB + PDF)
app.delete(
  "/invoices/by-filename/:filename",
  requireConfirmHeader("delete-invoice"),
  async (req, res) => {
    try {
      const fname = path.basename(req.params.filename);
      const ok = await invoicesRepo.deleteByFilename(fname);
      const p = findGeneratedFileDeep(fname);
      if (p && fs.existsSync(p)) {
        try {
          fs.unlinkSync(p);
        } catch {}
      }
      if (!ok) return res.status(404).json({ error: "Invoice not found" });
      return res.json({ success: true, filename: fname });
    } catch (e) {
      console.error("DELETE /invoices/by-filename error:", e);
      return res.status(500).json({ error: "Failed to delete invoice" });
    }
  }
);

// DELETE invoice by number (DB + PDF)
app.delete(
  "/invoices/by-number/:number",
  requireConfirmHeader("delete-invoice"),
  async (req, res) => {
    try {
      const num = String(req.params.number || "");
      const ok = await invoicesRepo.deleteByNumber(num);
      const safe = `Faktura_${num.replaceAll("/", "_")}.pdf`;
      const p = findGeneratedFileDeep(safe);
      if (p && fs.existsSync(p)) {
        try {
          fs.unlinkSync(p);
        } catch {}
      }
      if (!ok) return res.status(404).json({ error: "Invoice not found" });
      return res.json({ success: true, number: num });
    } catch (e) {
      console.error("DELETE /invoices/by-number error:", e);
      return res.status(500).json({ error: "Failed to delete invoice" });
    }
  }
);

app.get("/saved-invoices", (_req, res) => {
  const invoices = [];
  function readFolder(folderPath, parent = "") {
    if (!fs.existsSync(folderPath)) return;
    const entries = fs.readdirSync(folderPath, { withFileTypes: true });
    for (const entry of entries) {
      const fullPath = path.join(folderPath, entry.name);
      const relativePath = path.join(parent, entry.name);
      if (entry.isDirectory()) readFolder(fullPath, relativePath);
      else if (entry.name.toLowerCase().endsWith(".pdf"))
        invoices.push(relativePath);
    }
  }
  readFolder(GENERATED_DIR);
  res.json(invoices);
});

app.post("/save-invoices", async (req, res) => {
  const invoices = req.body;
  if (!Array.isArray(invoices)) {
    return res.status(400).json({ error: "Invalid invoices payload" });
  }

  try {
    // –∫–æ–∂–µ–Ω —ñ–Ω–≤–æ–π—Å -> –≤ MySQL
    for (const inv of invoices) {
      const invN = { ...inv, clientName: inv.clientName || inv.client || "" };

      try {
        await invoicesRepo.insertInvoice(invN);
      } catch (e) {
        console.warn(
          "‚ö†Ô∏è insertInvoice failed for",
          inv?.number,
          e?.message || e
        );
      }
    }

    // –¥–æ–¥–∞—Ç–∫–æ–≤–æ ‚Äî –∞–≤—Ç–æ–≥–µ–Ω–µ—Ä–∞—Ü—ñ—è PDF, —â–æ–± —Ñ–∞–π–ª —ñ—Å–Ω—É–≤–∞–≤ —É /generated
    setImmediate(async () => {
      for (const inv of invoices) {
        try {
          const fname =
            inv.filename ||
            `Faktura_${String(inv.number || "").replaceAll("/", "_")}.pdf`;

          const exists = findGeneratedFileDeep(path.basename(fname));
          if (!exists) {
            await ensurePdfForInvoice(inv);
          }
        } catch (e) {
          console.warn(
            "‚ö†Ô∏è PDF gen after save failed for",
            inv?.number,
            e?.message || e
          );
        }
      }
    });

    res.json({ success: true });
  } catch (err) {
    console.error("‚ùå Error saving invoices to DB:", err);
    res.status(500).json({ error: "Failed to save invoices" });
  }
});

app.get("/download-invoice/:filename", async (req, res) => {
  const fn = path.basename(req.params.filename);

  try {
    // 1. —à—É–∫–∞—î–º–æ —ñ–Ω–≤–æ–π—Å —É –ë–î –ø–æ —ñ–º–µ–Ω—ñ —Ñ–∞–π–ª—É
    const dbRows = await invoicesRepo.queryInvoiceByFilename(fn);

    if (dbRows && dbRows.length) {
      const row = dbRows[0];

      // –ø—Ä–∏–≤–µ—Å—Ç–∏ —Ñ–æ—Ä–º–∞—Ç —Ä—è–¥–∫–∞ –∑ –ë–î –¥–æ —Ñ–æ—Ä–º–∞—Ç—É, —è–∫–∏–π –æ—á—ñ–∫—É—î ensurePdfForInvoice()
      const invLikeOld = {
        number: row.number,
        client: row.clientName,
        issueDate: row.issueDate,
        dueDate: row.dueDate,
        net: row.net,
        gross: row.gross,
        filename: row.filename,
        folder: row.folder,
        items: (() => {
          try {
            return JSON.parse(row.items_json || "[]");
          } catch {
            return [];
          }
        })(),
        buyer_address: row.buyer_address,
        buyer_nip: row.buyer_nip,
        buyer_pesel: row.buyer_pesel,
        status: row.status,
      };

      const p = await ensurePdfForInvoice(invLikeOld, { force: true });
      res.setHeader("Content-Type", "application/pdf");
      res.setHeader("Content-Disposition", `inline; filename="${fn}"`);
      return res.sendFile(p);
    }

    // 2. fallback: —à—É–∫–∞—î–º–æ —Ñ—ñ–∑–∏—á–Ω–∏–π PDF —Ñ–∞–π–ª –Ω–∞ –¥–∏—Å–∫—É
    const p = findGeneratedFileDeep(fn);
    if (p && fs.existsSync(p)) {
      res.setHeader("Content-Type", "application/pdf");
      res.setHeader("Content-Disposition", `inline; filename="${fn}"`);
      return res.sendFile(p);
    }

    return res.status(404).send("Nie znaleziono faktury.");
  } catch (e) {
    console.error("‚ùå /download-invoice error:", e);
    return res.status(500).send("Internal server error");
  }
});

/* -----------------------------
 * Download multiple PDF as ZIP
 * ----------------------------- */
// Download multiple PDF as ZIP ‚Äî –ø–µ—Ä–µ–≥–µ–Ω–µ—Ä–∞—Ü—ñ—è –∑ –ë–î –ø–µ—Ä–µ–¥ —É–ø–∞–∫–æ–≤–∫–æ—é
app.post("/download-multiple", async (req, res) => {
  try {
    const { files } = req.body || {};
    if (!Array.isArray(files) || !files.length) {
      return res.status(400).json({ error: "Niepoprawna lista plik√≥w" });
    }

    // –ø—ñ–¥–≥–æ—Ç—É—î–º–æ –∞–±—Å–æ–ª—é—Ç–Ω—ñ —à–ª—è—Ö–∏, –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–æ —Å–≤—ñ–∂—ñ
    const pathsToZip = [];
    for (const filename of files) {
      const safe = path.basename(String(filename || ""));
      // —è–∫—â–æ —î –≤ –ë–î ‚Äî –ø–µ—Ä–µ–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ –∞–∫—Ç—É–∞–ª—å–Ω–∏–π PDF —ñ –≤–∑—è—Ç–∏ –π–æ–≥–æ —à–ª—è—Ö
      const dbRows = await invoicesRepo.queryInvoiceByFilename(safe);
      if (dbRows && dbRows.length) {
        const row = dbRows[0];
        const invLikeOld = {
          number: row.number,
          client: row.clientName,
          issueDate: row.issueDate,
          dueDate: row.dueDate,
          net: row.net,
          gross: row.gross,
          filename: row.filename,
          folder: row.folder,
          items: (() => {
            try {
              return JSON.parse(row.items_json || "[]");
            } catch {
              return [];
            }
          })(),
          buyer_address: row.buyer_address,
          buyer_nip: row.buyer_nip,
          buyer_pesel: row.buyer_pesel,
          status: row.status,
        };
        // ensurePdfForInvoice –≤—Å–µ—Ä–µ–¥–∏–Ω—ñ –≤–∏—Å—Ç–∞–≤–ª—è—î amount_in_words –ø—É—Å—Ç–∏–º ‚Üí PDFKit –≤–∏–ø–∏—à–µ —Å–ª–æ–≤–∞–º–∏
        const freshPath = await ensurePdfForInvoice(invLikeOld, {
          force: true,
        });
        if (freshPath && fs.existsSync(freshPath)) {
          pathsToZip.push(freshPath);
          continue;
        }
      }

      // fallback: —Ñ—ñ–∑–∏—á–Ω–∏–π —Ñ–∞–π–ª –∑ –¥–∏—Å–∫–∞ (—è–∫—â–æ –Ω–µ–º–∞ –≤ –ë–î)
      const found = findGeneratedFileDeep(safe);
      if (found && fs.existsSync(found)) {
        pathsToZip.push(found);
      } else {
        console.warn("[ZIP] File not found:", safe);
      }
    }

    if (!pathsToZip.length) {
      return res.status(404).json({ error: "Brak plik√≥w do spakowania" });
    }

    const archiver = require("archiver");
    const archive = archiver("zip", { zlib: { level: 9 } });
    res.attachment("wybrane_faktury.zip");
    archive.on("error", (err) => {
      console.error("‚ùå Archiver error:", err);
      if (!res.headersSent) res.status(500).end();
    });
    res.setHeader("Content-Type", "application/zip");

    archive.pipe(res);

    for (const p of pathsToZip) {
      archive.file(p, { name: path.basename(p) });
    }
    await archive.finalize();
  } catch (e) {
    console.error("‚ùå ZIP build error:", e);
    if (!res.headersSent)
      res.status(500).json({ error: "ZIP generation error" });
  }
});

/* =============================
 * PROTOCOLS
 * ============================= */

/* =============================
 * PROTOCOLS (DB-backed)
 * ============================= */

/* ---- low-level DB helpers ---- */

// –ó–ê–ú–Ü–ù–ò –í–ï–°–¨ –ë–õ–û–ö –§–£–ù–ö–¶–Ü–á dbListProtocolsWithEntriesLite –ù–ê –ù–ò–ñ–ß–ï
async function dbListProtocolsWithEntriesLite() {
  const rows = await sql(`
    SELECT
      p.id        AS protocolId,
      p.clientId  AS clientId,
      p.month     AS month,
      p.summarized AS summarized,
      p.createdAt AS createdAt,
      p.updatedAt AS updatedAt,
      e.date      AS e_date,
      e.packages  AS e_packages,
      e.returnDate AS e_returnDate
    FROM protocols p
    LEFT JOIN protocol_entries e ON e.protocol_id = p.id
    ORDER BY p.month DESC, p.clientId ASC, e.date ASC, e.id ASC
  `);

  if (!rows.length) return [];

  const byProto = new Map();
  for (const r of rows) {
    if (!byProto.has(r.protocolId)) {
      byProto.set(r.protocolId, {
        id: r.clientId,
        month: r.month,
        summarized: !!r.summarized,
        createdAt: r.createdAt,
        updatedAt: r.updatedAt,
        entries: [],
      });
    }
    // —è–∫—â–æ —Ä—è–¥–∫–∞ –Ω–µ–º–∞—î ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞—î–º–æ
    if (r.e_date == null && r.e_packages == null) continue;

    byProto.get(r.protocolId).entries.push({
      date: toISO10(r.e_date),
      packages: Number(r.e_packages ?? 0) || 0,
      tools: [], // –¥–ª—è —Å–ø–∏—Å–∫—É –Ω–µ –ø–æ—Ç—Ä—ñ–±–Ω–æ; —É view –ø—ñ–¥—Ç—è–≥—É—î—Ç—å—Å—è –ø–æ–≤–Ω–∏–π –ø—Ä–æ—Ç–æ–∫–æ–ª
      returnDate: toISO10(r.e_returnDate),
    });
  }

  return Array.from(byProto.values());
}

// server.js ‚Äî –∑–∞–º—ñ–Ω–∞ —Ñ—É–Ω–∫—Ü—ñ—ó parseJSON
function parseJSON(val, fallback) {
  try {
    if (val == null) return fallback;
    if (Buffer.isBuffer(val)) {
      val = val.toString("utf8");
    }
    // —è–∫—â–æ –¥—Ä–∞–π–≤–µ—Ä MySQL (mysql2) –≤–∂–µ —Ä–æ–∑–ø–∞—Ä—Å–∏–≤ JSON-–∫–æ–ª–æ–Ω–∫—É:
    if (typeof val === "object") {
      return val ?? fallback;
    }
    if (typeof val !== "string") {
      val = String(val ?? "");
    }
    if (!val.trim()) return fallback;
    return JSON.parse(val);
  } catch {
    return fallback;
  }
}

function nowForSQL() {
  // –õ–æ–∫–∞–ª—å–Ω–∏–π —á–∞—Å —Å–µ—Ä–≤–µ—Ä–∞ —É —Ñ–æ—Ä–º–∞—Ç—ñ "YYYY-MM-DD HH:MM:SS"
  const d = new Date();
  const pad = (n) => String(n).padStart(2, "0");

  const Y = d.getFullYear();
  const M = pad(d.getMonth() + 1);
  const D = pad(d.getDate());
  const h = pad(d.getHours());
  const m = pad(d.getMinutes());
  const s = pad(d.getSeconds());

  return `${Y}-${M}-${D} ${h}:${m}:${s}`;
}

async function dbGetProtocolFull(clientId, month) {
  const [proto] = await sql(
    `
      SELECT
        p.id         AS protocolId,
        p.clientId   AS clientId,
        p.month      AS month,
        p.summarized AS summarized,
        p.createdAt  AS createdAt,
        p.updatedAt  AS updatedAt
      FROM protocols p
      WHERE p.clientId=? AND p.month=?
      LIMIT 1
    `,
    [clientId, month]
  );

  if (!proto) {
    return {
      id: clientId,
      month,
      summarized: false,
      entries: [],
      totals: { totalPackages: 0 },
    };
  }

  let entriesRows = [];
  // 1) –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∏–π –Ω–∞–±—ñ—Ä –ø–æ–ª—ñ–≤ (–Ω–æ–≤–∞ —Å—Ö–µ–º–∞)
  const fullSelect = `
      SELECT
        e.id                 AS entryId,
        e.date               AS date,
        e.packages           AS packages,
        e.delivery           AS delivery,
        e.shipping           AS shipping,
        e.comment            AS comment,
        e.tools_json         AS tools_json,
        e.signatures_json    AS signatures_json,
        e.courierPending     AS courierPending,
        e.pointPending       AS pointPending,
        e.courierPlannedDate AS courierPlannedDate,
        e.returnDate         AS returnDate,
        e.returnPackages     AS returnPackages,
        e.returnDelivery     AS returnDelivery,
        e.returnShipping     AS returnShipping,
        e.returnTools_json   AS returnTools_json,
        e.transferClientSig  AS transferClientSig,
        e.transferStaffSig   AS transferStaffSig,
        e.returnClientSig    AS returnClientSig,
        e.returnStaffSig     AS returnStaffSig,
        e.queue_json         AS queue_json
      FROM protocol_entries e
      WHERE e.protocol_id=?
      ORDER BY e.date ASC, e.id ASC
  `;
  // 2) —Å–µ—Ä–µ–¥–Ω—ñ–π –Ω–∞–±—ñ—Ä –ø–æ–ª—ñ–≤ (—á–∞—Å—Ç–∫–æ–≤–æ –Ω–æ–≤–∞ —Å—Ö–µ–º–∞)
  const midSelect = `
      SELECT
        e.id               AS entryId,
        e.date             AS date,
        e.packages         AS packages,
        e.delivery         AS delivery,
        e.shipping         AS shipping,
        e.comment          AS comment,
        e.tools_json       AS tools_json,
        e.signatures_json  AS signatures_json
      FROM protocol_entries e
      WHERE e.protocol_id=?
      ORDER BY e.date ASC, e.id ASC
  `;
  // 3) –º—ñ–Ω—ñ–º–∞–ª—å–Ω–∞ —Å—É–º—ñ—Å–Ω—ñ—Å—Ç—å (—Å—Ç–∞—Ä–∞ —Å—Ö–µ–º–∞ –±–µ–∑ JSON-–∫–æ–ª–æ–Ω–æ–∫)
  const minSelect = `
      SELECT
        e.id       AS entryId,
        e.date     AS date,
        e.packages AS packages,
        e.delivery AS delivery,
        e.shipping AS shipping,
        e.comment  AS comment
      FROM protocol_entries e
      WHERE e.protocol_id=?
      ORDER BY e.date ASC, e.id ASC
  `;

  try {
    entriesRows = await sql(fullSelect, [proto.protocolId]);
  } catch {
    try {
      entriesRows = await sql(midSelect, [proto.protocolId]);
    } catch {
      entriesRows = await sql(minSelect, [proto.protocolId]);
    }
  }

  const entries = entriesRows.map((r) => {
    const tools = r.hasOwnProperty("tools_json")
      ? parseJSON(r.tools_json, [])
      : [];
    // –ø—ñ–¥–ø–∏—Å–∏: –∑ JSON, –∞–±–æ –∑—ñ —Å—Ç–∞—Ä–∏—Ö –∫–æ–ª–æ–Ω–æ–∫, –∞–±–æ –ø–æ—Ä–æ–∂–Ω—å–æ
    let signatures = r.hasOwnProperty("signatures_json")
      ? parseJSON(r.signatures_json, {})
      : {};
    if (
      (!signatures || !Object.keys(signatures).length) &&
      (r.transferClientSig ||
        r.transferStaffSig ||
        r.returnClientSig ||
        r.returnStaffSig)
    ) {
      signatures = {};
      if (r.transferClientSig || r.transferStaffSig) {
        signatures.transfer = {};
        if (r.transferClientSig)
          signatures.transfer.client = r.transferClientSig;
        if (r.transferStaffSig) signatures.transfer.staff = r.transferStaffSig;
      }
      if (r.returnClientSig || r.returnStaffSig) {
        signatures.return = {};
        if (r.returnClientSig) signatures.return.client = r.returnClientSig;
        if (r.returnStaffSig) signatures.return.staff = r.returnStaffSig;
      }
    }

    // —á–µ—Ä–≥–∞: JSON ‚Üí –∫–æ–ª–æ–Ω–∫–∏ ‚Üí –¥–µ—Ñ–æ–ª—Ç
    let queue = {};
    if (r && r.hasOwnProperty("queue_json")) {
      const q = parseJSON(r.queue_json, null);
      if (q && typeof q === "object") {
        queue = {
          courierPending: !!q.courierPending,
          pointPending: !!q.pointPending,
          courierPlannedDate: toISO10(q.courierPlannedDate),
        };
      }
    }
    if (
      !Object.keys(queue).length &&
      (r.hasOwnProperty("courierPending") || r.hasOwnProperty("pointPending"))
    ) {
      queue = {
        courierPending: !!r.courierPending,
        pointPending: !!r.pointPending,
        courierPlannedDate: toISO10(r.courierPlannedDate),
      };
    }

    // –±–ª–æ–∫ –ø–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è: —è–∫—â–æ –∫–æ–ª–æ–Ω–æ–∫ –Ω–µ–º–∞—î ‚Äî –∑–∞–ª–∏—à–∞—î–º–æ null/–ø–æ—Ä–æ–∂–Ω—å–æ
    const ret = {
      returnDate: r.hasOwnProperty("returnDate") ? toISO10(r.returnDate) : null,
      returnPackages: r.hasOwnProperty("returnPackages")
        ? r.returnPackages ?? null
        : null,
      returnDelivery: r.hasOwnProperty("returnDelivery")
        ? r.returnDelivery || null
        : null,
      returnShipping: r.hasOwnProperty("returnShipping")
        ? !!r.returnShipping
        : false,
      returnTools: r.hasOwnProperty("returnTools_json")
        ? parseJSON(r.returnTools_json, [])
        : [],
    };

    return {
      entryId: r.entryId,
      date: toISO10(r.date),
      packages: Number(r.packages || 0) || 0,
      delivery: r.delivery || null,
      shipping: !!r.shipping,
      comment: r.comment || "",
      tools,
      signatures,
      queue,
      ...ret,
    };
  });

  const totalPackages = entries.reduce(
    (sum, e) => sum + (Number(e.packages || 0) || 0),
    0
  );

  return {
    id: proto.clientId,
    month: proto.month,
    summarized: !!proto.summarized,
    entries,
    totals: { totalPackages },
  };
}

async function dbEnsureProtocolHeader(clientId, month) {
  const existing = await sql(
    `SELECT id FROM protocols WHERE clientId=? AND month=? LIMIT 1`,
    [clientId, month]
  );

  if (existing.length) {
    await sql(`UPDATE protocols SET updatedAt=? WHERE id=?`, [
      nowForSQL(),
      existing[0].id,
    ]);
    return existing[0].id;
  } else {
    const now = nowForSQL();
    const result = await sql(
      `
        INSERT INTO protocols (clientId, month, summarized, createdAt, updatedAt)
        VALUES (?, ?, ?, ?, ?)
      `,
      [clientId, month, 0, now, now]
    );
    return result.insertId;
  }
}

async function dbUpsertEntry({ protocolId, index, newEntry }) {
  // 1. –î—ñ—Å—Ç–∞—î–º–æ –≤—Å—ñ —Ä—è–¥–∫–∏ –ø—Ä–æ—Ç–æ–∫–æ–ª—É, —â–æ–± –∑–Ω–∞—Ç–∏ id –∑–∞–ø–∏—Å—É –∑ —Ç–∞–∫–∏–º index
  const rows = await sql(
    `
      SELECT
        e.id
      FROM protocol_entries e
      WHERE e.protocol_id=?
      ORDER BY e.date ASC, e.id ASC
    `,
    [protocolId]
  );

  const isUpdate = Number.isInteger(index) && index >= 0 && index < rows.length;

  if (isUpdate) {
    const targetId = rows[index].id;

    // —Å–ø—Ä–æ–±–∞ –ü–û–í–ù–û–ì–û UPDATE (–Ω–æ–≤–∞ —Å—Ö–µ–º–∞)
    const fullSQL = `
      UPDATE protocol_entries
      SET
        date=?,
        packages=?,
        delivery=?,
        shipping=?,
        comment=?,
        tools_json=?,
        signatures_json=?,
        courierPending=?,
        pointPending=?,
        courierPlannedDate=?,
        returnDate=?,
        returnPackages=?,
        returnDelivery=?,
        returnShipping=?,
        returnTools_json=?
      WHERE id=?
    `;
    const fullParams = [
      newEntry.date,
      newEntry.packages,
      newEntry.delivery,
      newEntry.shipping ? 1 : 0,
      newEntry.comment,
      JSON.stringify(newEntry.tools || []),
      JSON.stringify(newEntry.signatures || {}),
      newEntry.queue?.courierPending ? 1 : 0,
      newEntry.queue?.pointPending ? 1 : 0,
      newEntry.queue?.courierPlannedDate || null,
      newEntry.returnDate || null,
      newEntry.returnPackages ?? null,
      newEntry.returnDelivery || null,
      newEntry.returnShipping ? 1 : 0,
      JSON.stringify(newEntry.returnTools || []),
      targetId,
    ];

    try {
      await sql(fullSQL, fullParams);
    } catch (err) {
      console.warn(
        "‚ö†Ô∏è FULL UPDATE failed, fallback to BASIC UPDATE",
        err?.sqlMessage || err
      );

      // fallback: —Å—Ç–∞—Ä—ñ –∫–æ–ª–æ–Ω–∫–∏, —è–∫—ñ —Ç–æ—á–Ω–æ —ñ—Å–Ω—É—é—Ç—å —É —Ç–≤–æ—ó–π —Ç–∞–±–ª–∏—Ü—ñ –∑–∞—Ä–∞–∑
      await sql(
        `
          UPDATE protocol_entries
          SET
            date=?,
            packages=?,
            delivery=?,
            shipping=?,
            comment=?,
            tools_json=?,
            signatures_json=?
          WHERE id=?
        `,
        [
          newEntry.date,
          newEntry.packages,
          newEntry.delivery,
          newEntry.shipping ? 1 : 0,
          newEntry.comment,
          JSON.stringify(newEntry.tools || []),
          JSON.stringify(newEntry.signatures || {}),
          targetId,
        ]
      );
    }

    return targetId;
  }

  // INSERT (append —É –∫—ñ–Ω–µ—Ü—å –ø—Ä–æ—Ç–æ–∫–æ–ª—É)
  const fullInsertSQL = `
    INSERT INTO protocol_entries (
      protocol_id,
      date,
      packages,
      delivery,
      shipping,
      comment,
      tools_json,
      signatures_json,
      courierPending,
      pointPending,
      courierPlannedDate,
      returnDate,
      returnPackages,
      returnDelivery,
      returnShipping,
      returnTools_json
    )
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `;
  const fullInsertParams = [
    protocolId,
    newEntry.date,
    newEntry.packages,
    newEntry.delivery,
    newEntry.shipping ? 1 : 0,
    newEntry.comment,
    JSON.stringify(newEntry.tools || []),
    JSON.stringify(newEntry.signatures || {}),
    newEntry.queue?.courierPending ? 1 : 0,
    newEntry.queue?.pointPending ? 1 : 0,
    newEntry.queue?.courierPlannedDate || null,
    newEntry.returnDate || null,
    newEntry.returnPackages ?? null,
    newEntry.returnDelivery || null,
    newEntry.returnShipping ? 1 : 0,
    JSON.stringify(newEntry.returnTools || []),
  ];

  try {
    const result = await sql(fullInsertSQL, fullInsertParams);
    return result.insertId;
  } catch (err) {
    console.warn(
      "‚ö†Ô∏è FULL INSERT failed, fallback to BASIC INSERT",
      err?.sqlMessage || err
    );

    // fallback –±–µ–∑ –Ω–æ–≤–∏—Ö –∫–æ–ª–æ–Ω–æ–∫
    const basicResult = await sql(
      `
        INSERT INTO protocol_entries (
          protocol_id,
          date,
          packages,
          delivery,
          shipping,
          comment,
          tools_json,
          signatures_json
        )
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `,
      [
        protocolId,
        newEntry.date,
        newEntry.packages,
        newEntry.delivery,
        newEntry.shipping ? 1 : 0,
        newEntry.comment,
        JSON.stringify(newEntry.tools || []),
        JSON.stringify(newEntry.signatures || {}),
      ]
    );
    return basicResult.insertId;
  }
}

// –≤–∏–¥–∞–ª–∏—Ç–∏ –∑–∞–ø–∏—Å –∑–∞ —ñ–Ω–¥–µ–∫—Å–æ–º
async function dbDeleteEntryByIndex(clientId, month, index) {
  // –∑–Ω–∞–π—Ç–∏ protocolId
  const [proto] = await sql(
    `SELECT id FROM protocols WHERE clientId=? AND month=? LIMIT 1`,
    [clientId, month]
  );
  if (!proto) return false;

  // —Ç—è–≥–Ω–µ–º–æ –≤–ø–æ—Ä—è–¥–∫–æ–≤–∞–Ω—ñ —Ä—è–¥–∫–∏
  const rows = await sql(
    `
      SELECT e.id
      FROM protocol_entries e
      WHERE e.protocol_id=?
      ORDER BY e.date ASC, e.id ASC
    `,
    [proto.id]
  );
  if (!Number.isInteger(index) || index < 0 || index >= rows.length) {
    return false;
  }
  const entryId = rows[index].id;
  await sql(`DELETE FROM protocol_entries WHERE id=?`, [entryId]);
  return true;
}

async function dbSetSummarized(clientId, month, summarized) {
  await dbEnsureProtocolHeader(clientId, month);
  await sql(
    `UPDATE protocols SET summarized=?, updatedAt=? WHERE clientId=? AND month=?`,
    [summarized ? 1 : 0, nowForSQL(), clientId, month]
  );
}

// —É—Ç–∏–ª—ñ—Ç–∏, —è–∫—ñ –∑–∞–ª–∏—à–∞—é—Ç—å—Å—è —Å–ø—ñ–ª—å–Ω–∏–º–∏
function computeMonthlyTotals(proto) {
  const totalPackages = (proto.entries || []).reduce(
    (sum, e) => sum + (Number(e.packages || 0) || 0),
    0
  );
  return { totalPackages };
}
function todayISO() {
  return todayLocalISO();
}

function isISODate(s) {
  return typeof s === "string" && /^\d{4}-\d{2}-\d{2}$/.test(s);
}

function toISODatePlain(x) {
  if (typeof x !== "string") return "";
  const m = x.match(/^(\d{4}-\d{2}-\d{2})/);
  return m ? m[1] : "";
}
function todayLocalISO() {
  const d = new Date();
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, "0");
  const dd = String(d.getDate()).padStart(2, "0");
  return `${y}-${m}-${dd}`;
}

function ymFromISO(iso) {
  return typeof iso === "string" && /^\d{4}-\d{2}-\d{2}$/.test(iso)
    ? iso.slice(0, 7)
    : null;
}

/* –∫–ª—ñ—î–Ω—Ç–∏ (–¥–ª—è —á–µ—Ä–≥–∏) */
async function dbGetAllClientsIndex() {
  const rows = await clientsRepo.getAllClients();
  const idx = {};
  for (const c of rows) {
    const name =
      c?.name ||
      c?.Klient ||
      c?.client ||
      c?.Client ||
      c?.buyer_name ||
      c?.Buyer ||
      "";
    const id = c?.id || c?.ID || slugFromName(name);
    if (id) {
      idx[id] = {
        name: name || id,
        logistics: c?.logistics || "",
      };
    }
  }
  return idx;
}
function stripDiacritics(s) {
  return String(s || "")
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "");
}
function slugFromName(name) {
  return stripDiacritics(String(name || ""))
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/(^-|-$)/g, "");
}
function deriveInitialQueue(logistics) {
  const v = String(logistics || "")
    .toLowerCase()
    .trim();
  return {
    pointPending: v === "punkt",
    courierPending: v === "kurier",
  };
}
function normalizeToolsArray(raw) {
  // –ü—Ä–∏–≤–æ–¥–∏—Ç—å –±—É–¥—å-—è–∫–∏–π —Ñ–æ—Ä–º–∞—Ç –¥–æ [{ name: "...", count: number }]
  if (!raw || !Array.isArray(raw)) return [];
  return raw
    .map((t) => {
      if (typeof t === "string") {
        return { name: t.trim(), count: 0 };
      }
      if (t && typeof t === "object") {
        return {
          name: String(t.name || t.nazwa || "").trim(),
          count: Number(t.count || t.ilosc || 0) || 0,
        };
      }
      return null;
    })
    .filter(Boolean);
}

app.get("/protocols", async (_req, res) => {
  try {
    const list = await dbListProtocolsWithEntriesLite();
    return res.json(Array.isArray(list) ? list : []);
  } catch (e) {
    console.error("‚ùå Error reading protocols list:", e);
    res.status(500).json({ error: "Failed to load protocols list" });
  }
});

app.get("/protocols/:month/zip", (req, res) => {
  try {
    return createProtocolZip(req, res);
  } catch (e) {
    console.error("‚ùå PDF zip error:", e);
    if (!res.headersSent) res.status(500).send("ZIP generation error");
  }
});

app.get("/protocols/:clientId/:month/pdf", (req, res) => {
  Promise.resolve(createProtocolPDF(req, res)).catch((e) => {
    console.error("‚ùå PDF protocol error:", e);
    if (!res.headersSent) res.status(500).send("PDF generation error");
  });
});

// server.cjs ‚Äî –î–û–î–ê–ô –¶–ï–ô –ú–ê–†–®–†–£–¢ ZIP –î–õ–Ø –í–ò–ë–†–ê–ù–ò–• –ü–†–û–¢–û–ö–û–õ–Ü–í
app.post("/protocols/zip", async (req, res) => {
  try {
    const { pairs } = req.body || {};
    if (!Array.isArray(pairs) || !pairs.length) {
      return res.status(400).json({
        error: "pairs must be a non-empty array [{ clientId, month }]",
      });
    }

    const archiver = require("archiver");
    const archive = archiver("zip", { zlib: { level: 9 } });

    const safeName = (s) =>
      String(s || "")
        .normalize("NFD")
        .replace(/[\u0300-\u036f]/g, "")
        .replace(/[^a-zA-Z0-9._-]+/g, "_")
        .replace(/^_+|_+$/g, "");

    res.attachment(`protokoly_${Date.now()}.zip`);
    archive.on("error", (err) => {
      console.error("ZIP error:", err);
      if (!res.headersSent) res.status(500).end();
    });
    archive.pipe(res);

    // –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –ª–æ–∫–∞–ª—å–Ω–∏–π HTTP –≤–∏–∫–ª–∏–∫ –¥–æ —ñ—Å–Ω—É—é—á–æ–≥–æ PDF-—Ä–æ—É—Ç—É
    const base = `http://127.0.0.1:${PORT}`;
    for (const it of pairs) {
      const clientId = String(it.clientId || "").trim();
      const month = String(it.month || "").trim();
      if (!clientId || !/^\d{4}-\d{2}$/.test(month)) continue;

      const url = `${base}/protocols/${encodeURIComponent(
        clientId
      )}/${month}/pdf`;
      try {
        const r = await fetch(url);
        if (!r.ok || !r.body) {
          console.warn("Skip (no PDF):", clientId, month, r.status);
          continue;
        }
        const name = safeName(`Protokol_${clientId}_${month}.pdf`);
        const ab = await r.arrayBuffer();
        archive.append(Buffer.from(ab), { name });
      } catch (e) {
        console.warn("Fetch fail:", clientId, month, e?.message || e);
      }
    }

    await archive.finalize();
  } catch (e) {
    console.error("POST /protocols/zip error:", e);
    if (!res.headersSent)
      res.status(500).json({ error: "ZIP generation error" });
  }
});

/* ---- –û–¥–∏–Ω –ø—Ä–æ—Ç–æ–∫–æ–ª (–ø–æ–≤–Ω–∏–π) ---- */
app.get("/protocols/:clientId/:month", async (req, res) => {
  try {
    const clientId = decodeURIComponent(req.params.clientId);
    const month = req.params.month;
    if (!/^\d{4}-\d{2}$/.test(month)) {
      return res.status(400).json({ error: "Invalid month format" });
    }

    const proto = await dbGetProtocolFull(clientId, month);
    res.json(proto);
  } catch (e) {
    console.error("‚ùå Error reading protocol (DB):", e);
    res.status(500).json({ error: "Failed to load protocol" });
  }
});

/* ---- –î–æ–¥–∞–≤–∞–Ω–Ω—è / —Ä–µ–¥–∞–≥—É–≤–∞–Ω–Ω—è –æ–¥–Ω–æ–≥–æ –∑–∞–ø–∏—Å—É –ø—Ä–æ—Ç–æ–∫–æ–ª—É ---- */
app.post("/protocols/:clientId/:month", async (req, res) => {
  try {
    const { clientId, month } = req.params;
    if (!/^\d{4}-\d{2}$/.test(month)) {
      return res.status(400).json({ error: "Invalid month format" });
    }

    const entry = req.body || {};
    const date = entry.date ? String(entry.date) : null;
    if (!date) {
      return res.status(400).json({ error: "Brak 'date' w wpisie" });
    }

    // normalize tools
    const tools = Array.isArray(entry.tools)
      ? entry.tools.map((t) => ({
          name: String(t?.name || "").trim(),
          count: Number(t?.count || 0) || 0,
        }))
      : [];

    const packages = Number(entry.packages || 0) || 0;
    const delivery = entry.delivery || null;
    const shipping = !!entry.shipping;
    const comment = String(entry.comment || "");

    // signatures ‚Üí —Ñ–∞–π–ª–∏ –Ω–∞ –¥–∏—Å–∫ —è–∫ —Ä–∞–Ω—ñ—à–µ
    function saveSignatureDataURL(dataURL, roleKey) {
      if (!dataURL || typeof dataURL !== "string") return null;
      const m = /^data:image\/(png|jpeg);base64,([A-Za-z0-9+/=]+)$/.exec(
        dataURL
      );
      if (!m) return null;
      const ext = m[1] === "jpeg" ? "jpg" : "png";
      const b64 = m[2];

      const dir = path.join(SIGNATURES_DIR, safeSeg(clientId), safeSeg(month));
      if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });

      const file = `${roleKey}_${Date.now()}_${Math.random()
        .toString(36)
        .slice(2, 8)}.${ext}`;
      const abs = path.join(dir, file);
      fs.writeFileSync(abs, Buffer.from(b64, "base64"));
      const pub = `/signatures/${encodeURIComponent(
        safeSeg(clientId)
      )}/${encodeURIComponent(safeSeg(month))}/${encodeURIComponent(file)}`;
      return pub;
    }

    let signatures;
    if (entry.signaturesData && typeof entry.signaturesData === "object") {
      const sd = entry.signaturesData;
      const transfer = {};
      const ret = {};
      if (sd.transfer && typeof sd.transfer === "object") {
        if (sd.transfer.client) {
          transfer.client = saveSignatureDataURL(
            sd.transfer.client,
            "transfer_client"
          );
        }
        if (sd.transfer.staff) {
          transfer.staff = saveSignatureDataURL(
            sd.transfer.staff,
            "transfer_staff"
          );
        }
      }
      if (sd.return && typeof sd.return === "object") {
        if (sd.return.client) {
          ret.client = saveSignatureDataURL(sd.return.client, "return_client");
        }
        if (sd.return.staff) {
          ret.staff = saveSignatureDataURL(sd.return.staff, "return_staff");
        }
      }
      const hasTransfer = transfer.client || transfer.staff;
      const hasReturn = ret.client || ret.staff;
      if (hasTransfer || hasReturn) {
        signatures = {};
        if (hasTransfer) signatures.transfer = transfer;
        if (hasReturn) signatures.return = ret;
      }
    }

    // queue –∞–≤—Ç–æ–≥–µ–Ω–µ—Ä–∞—Ü—ñ—è –∑ –ª–æ–≥—ñ—Å—Ç–∏–∫–∏ –∫–ª—ñ—î–Ω—Ç–∞
    const clientsIdx = await dbGetAllClientsIndex();
    const cli = clientsIdx[clientId] || {};
    let queue = deriveInitialQueue(cli.logistics || "");

    if (queue.courierPending) {
      // –∫—É—Ä'—î—Ä: –ø—Ä–æ—Å—Ç–∞–≤–ª—è—î–º–æ courierPlannedDate
      const plannedRaw =
        (typeof entry.courierPlannedDate === "string" &&
          /^\d{4}-\d{2}-\d{2}$/.test(entry.courierPlannedDate) &&
          entry.courierPlannedDate) ||
        (isISODate(date) && date) ||
        todayISO();

      queue.courierPlannedDate = plannedRaw;
      queue.pointPending = false;
    }

    if (queue.pointPending) {
      // –ø—É–Ω–∫—Ç: –±–µ–∑ –¥–∞—Ç–∏
      queue.courierPending = false;
      delete queue.courierPlannedDate;
    }

    const newEntry = {
      date,
      tools,
      packages,
      delivery,
      shipping,
      comment,
      signatures,
      queue,
      // –±–µ–∑ return* –Ω–∞ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—ñ
    };

    const editIndex = Number(entry._editIndex);

    const protocolId = await dbEnsureProtocolHeader(clientId, month);
    await dbUpsertEntry({
      protocolId,
      index: Number.isInteger(editIndex) ? editIndex : null,
      newEntry,
    });

    const protoFull = await dbGetProtocolFull(clientId, month);
    res.json({ success: true, protocol: protoFull });
  } catch (e) {
    console.error("‚ùå Error saving protocol (DB):", e);
    res.status(500).json({ error: "Failed to save protocol entry" });
  }
});

/* ---- –í–∏–¥–∞–ª–µ–Ω–Ω—è —Ä—è–¥–∫–∞ ---- */
app.delete("/protocols/:clientId/:month/:index", async (req, res) => {
  try {
    const { clientId, month, index } = req.params;
    const idx = Number(index);

    const ok = await dbDeleteEntryByIndex(clientId, month, idx);
    if (!ok) {
      return res.status(404).json({ error: "Protocol or entry not found" });
    }

    const protoFull = await dbGetProtocolFull(clientId, month);
    res.json({ success: true, protocol: protoFull });
  } catch (e) {
    console.error("‚ùå Error deleting protocol entry (DB):", e);
    res.status(500).json({ error: "Failed to delete protocol entry" });
  }
});

/* ---- –ü–æ–∑–Ω–∞—á–∫–∏ —á–µ—Ä–≥–∏ (courier/point) ---- */
app.post("/protocols/:clientId/:month/:index/queue", async (req, res) => {
  try {
    const { clientId, month, index } = req.params;
    const { type, pending } = req.body || {};
    if (!["courier", "point"].includes(type)) {
      return res.status(400).json({ error: "Invalid type" });
    }
    const idx = Number(index);

    const protoFull = await dbGetProtocolFull(clientId, month);
    const entry = protoFull.entries[idx];
    if (!entry) {
      return res.status(404).json({ error: "Entry not found" });
    }

    entry.queue = entry.queue || {
      courierPending: false,
      pointPending: false,
      courierPlannedDate: null,
    };
    if (type === "courier") entry.queue.courierPending = !!pending;
    if (type === "point") entry.queue.pointPending = !!pending;

    const protocolId = await dbEnsureProtocolHeader(clientId, month);
    await dbUpsertEntry({
      protocolId,
      index: idx,
      newEntry: entry,
    });

    const after = await dbGetProtocolFull(clientId, month);
    res.json({ success: true, entry: after.entries[idx] });
  } catch (e) {
    console.error("‚ùå Queue set error (DB):", e);
    res.status(500).json({ error: "Failed to set queue flag" });
  }
});

/* ---- CLEAR –æ–¥–Ω–æ–≥–æ –ø—Ä–∞–ø–æ—Ä—Ü—è —á–µ—Ä–≥–∏ ---- */
app.delete("/protocols/:clientId/:month/:index/queue", async (req, res) => {
  try {
    const { clientId, month, index } = req.params;
    const type =
      (req.body && req.body.type) || (req.query && req.query.type) || "";
    if (!["courier", "point"].includes(type)) {
      return res
        .status(400)
        .json({ error: "type must be 'courier' or 'point'" });
    }

    const idx = Number(index);

    const protoFull = await dbGetProtocolFull(clientId, month);
    const entry = protoFull.entries[idx];
    if (!entry) {
      return res.status(404).json({ error: "Entry not found" });
    }

    entry.queue = entry.queue || {
      courierPending: false,
      pointPending: false,
      courierPlannedDate: null,
    };
    if (type === "courier") entry.queue.courierPending = false;
    if (type === "point") entry.queue.pointPending = false;

    const protocolId = await dbEnsureProtocolHeader(clientId, month);
    await dbUpsertEntry({
      protocolId,
      index: idx,
      newEntry: entry,
    });

    const after = await dbGetProtocolFull(clientId, month);
    res.json({ success: true, entry: after.entries[idx] });
  } catch (e) {
    console.error("‚ùå Queue clear error (DB):", e);
    res.status(500).json({ error: "Failed to clear queue flag" });
  }
});

/* ---- –ó–±–µ—Ä–µ–∂–µ–Ω–Ω—è –ø—ñ–¥–ø–∏—Å—ñ–≤ (transfer/return) ---- */
app.post("/protocols/:clientId/:month/:index/sign", async (req, res) => {
  try {
    const { clientId, month, index } = req.params;
    const {
      leg, // 'transfer' | 'return'
      client: clientDataURL,
      staff: staffDataURL,
      useDefaultStaff,
    } = req.body || {};

    if (!["transfer", "return"].includes(leg)) {
      return res.status(400).json({ error: "Invalid leg" });
    }

    const idx = Number(index);
    const protoFull = await dbGetProtocolFull(clientId, month);
    const entry = protoFull.entries[idx];
    if (!entry) {
      return res.status(404).json({ error: "Entry not found" });
    }

    function saveSignatureDataURLStrict(dataURL, roleKey) {
      if (!dataURL || typeof dataURL !== "string")
        throw new Error("Invalid signature payload");
      const m = /^data:image\/(png|jpeg);base64,([A-Za-z0-9+/=]+)$/.exec(
        dataURL
      );
      if (!m) throw new Error("Invalid image dataURL");
      const ext = m[1] === "jpeg" ? "jpg" : "png";
      const b64 = m[2];

      const dir = path.join(SIGNATURES_DIR, safeSeg(clientId), safeSeg(month));
      if (!fs.existsSync(dir)) fs.mkdirSync(dir, { recursive: true });

      const file = `${roleKey}_${Date.now()}_${Math.random()
        .toString(36)
        .slice(2, 8)}.${ext}`;
      const abs = path.join(dir, file);
      fs.writeFileSync(abs, Buffer.from(b64, "base64"));
      const pub = `/signatures/${encodeURIComponent(
        safeSeg(clientId)
      )}/${encodeURIComponent(safeSeg(month))}/${encodeURIComponent(file)}`;
      return pub;
    }

    entry.signatures = entry.signatures || {};
    entry.signatures[leg] = entry.signatures[leg] || {};

    if (clientDataURL !== undefined) {
      try {
        entry.signatures[leg].client = saveSignatureDataURLStrict(
          clientDataURL,
          `${leg}_client`
        );
      } catch {
        return res
          .status(400)
          .json({ error: "Invalid client signature dataURL" });
      }
    }

    if (staffDataURL !== undefined && staffDataURL !== null) {
      try {
        entry.signatures[leg].staff = saveSignatureDataURLStrict(
          staffDataURL,
          `${leg}_staff`
        );
      } catch {
        return res
          .status(400)
          .json({ error: "Invalid staff signature dataURL" });
      }
    } else if (useDefaultStaff) {
      // –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–æ –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ/–æ–Ω–æ–≤–ª—é—î–º–æ —Ñ–∞–π–ª —â–æ—Ä–∞–∑—É
      DEFAULT_STAFF_SIG_PUBLIC = ensureStaticStaffSigPublic();
      if (!DEFAULT_STAFF_SIG_PUBLIC) {
        return res.status(400).json({
          error:
            "Brak domy≈õlnego podpisu pracownika (staff-sign.png/jpg). Nie mo≈ºna zastosowaƒá automatycznego podpisu.",
        });
      }
      entry.signatures[leg].staff = DEFAULT_STAFF_SIG_PUBLIC;
    }

    // —è–∫—â–æ –æ–±–∏–¥–≤—ñ —Å—Ç–æ—Ä–æ–Ω–∏ –ø—ñ–¥–ø–∏—Å–∞–Ω—ñ –≤ transfer —ñ return ‚Üí —á–µ—Ä–≥—É –≥–∞—Å–∏–º–æ
    const t = entry.signatures.transfer;
    const r = entry.signatures.return;
    const transferDone = !!(t && t.client && t.staff);
    const returnDone = !!(r && r.client && r.staff);
    if (transferDone && returnDone) {
      entry.queue = entry.queue || {
        courierPending: false,
        pointPending: false,
      };
      entry.queue.courierPending = false;
      entry.queue.pointPending = false;
    }

    const protocolId = await dbEnsureProtocolHeader(clientId, month);
    await dbUpsertEntry({
      protocolId,
      index: idx,
      newEntry: entry,
    });

    const after = await dbGetProtocolFull(clientId, month);
    res.json({ success: true, entry: after.entries[idx] });
  } catch (e) {
    console.error("‚ùå Sign save error (DB):", e);
    res.status(500).json({ error: "Failed to save signatures" });
  }
});

/* ---- –í–∏–¥–∞–ª–µ–Ω–Ω—è –ø—ñ–¥–ø–∏—Å—É ---- */
app.delete("/protocols/:clientId/:month/:index/sign", async (req, res) => {
  try {
    const { clientId, month, index } = req.params;
    const { leg, who } = req.body || {};
    if (!["transfer", "return"].includes(leg)) {
      return res.status(400).json({ error: "Invalid leg" });
    }
    if (!["staff", "client"].includes(who)) {
      return res.status(400).json({ error: "Invalid who" });
    }

    const idx = Number(index);
    const protoFull = await dbGetProtocolFull(clientId, month);
    const entry = protoFull.entries[idx];
    if (!entry) {
      return res.status(404).json({ error: "Entry not found" });
    }

    const currentPub = entry?.signatures?.[leg]?.[who] || null;

    function publicToAbsolute(pub) {
      if (!pub || typeof pub !== "string") return null;
      const rel = pub.replace(/^\/+/, "");
      const abs = path.join(ROOT, rel);
      if (abs.startsWith(SIGNATURES_DIR)) return abs;
      return null;
    }

    if (currentPub) {
      const abs = publicToAbsolute(currentPub);
      if (abs && fs.existsSync(abs)) {
        if (!currentPub.includes("/_static/")) {
          try {
            fs.unlinkSync(abs);
          } catch {}
        }
      }
      entry.signatures = entry.signatures || {};
      entry.signatures[leg] = entry.signatures[leg] || {};
      delete entry.signatures[leg][who];

      if (
        entry.signatures[leg] &&
        !entry.signatures[leg].client &&
        !entry.signatures[leg].staff
      ) {
        delete entry.signatures[leg];
      }
      if (
        entry.signatures &&
        !entry.signatures.transfer &&
        !entry.signatures.return
      ) {
        delete entry.signatures;
      }
    }

    const protocolId = await dbEnsureProtocolHeader(clientId, month);
    await dbUpsertEntry({
      protocolId,
      index: idx,
      newEntry: entry,
    });

    const after = await dbGetProtocolFull(clientId, month);
    res.json({ success: true, entry: after.entries[idx] });
  } catch (e) {
    console.error("‚ùå Sign delete error (DB):", e);
    res.status(500).json({ error: "Failed to delete signature" });
  }
});

/* ---- –û–Ω–æ–≤–ª–µ–Ω–Ω—è –ø–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è ---- */
app.post("/protocols/:clientId/:month/:index/return", async (req, res) => {
  try {
    const { clientId, month, index } = req.params;
    const idx = Number(index);
    const body = req.body || {};

    const protoFull = await dbGetProtocolFull(clientId, month);
    const entry = protoFull.entries[idx];
    if (!entry) {
      return res.status(404).json({ error: "Entry not found" });
    }

    if (
      typeof body.returnDate === "string" &&
      /^\d{4}-\d{2}-\d{2}$/.test(body.returnDate)
    ) {
      entry.returnDate = body.returnDate;
    }

    if (body.matchTransfer) {
      const src = Array.isArray(entry.tools) ? entry.tools : [];
      entry.returnTools = src.map((t) => ({
        name: String(t?.name || "").trim(),
        count: Number(t?.count || 0) || 0,
      }));
      entry.returnPackages = Number(
        body.returnPackages != null ? body.returnPackages : entry.packages || 0
      );
    } else if (Array.isArray(body.tools)) {
      entry.returnTools = body.tools.map((t) => ({
        name: String(t?.name || "").trim(),
        count: Number(t?.count || 0) || 0,
      }));
      if (body.returnPackages != null) {
        entry.returnPackages = Number(body.returnPackages) || 0;
      }
    } else if (body.returnPackages != null) {
      entry.returnPackages = Number(body.returnPackages) || 0;
    }

    if (
      body.returnDelivery == null ||
      ["odbior", "dowoz", "odbior+dowoz", null].includes(body.returnDelivery)
    ) {
      entry.returnDelivery =
        body.returnDelivery === undefined
          ? entry.returnDelivery
          : body.returnDelivery;
    }
    if (typeof body.returnShipping === "boolean") {
      entry.returnShipping = !!body.returnShipping;
    }

    const protocolId = await dbEnsureProtocolHeader(clientId, month);
    await dbUpsertEntry({
      protocolId,
      index: idx,
      newEntry: entry,
    });

    const after = await dbGetProtocolFull(clientId, month);
    res.json({
      success: true,
      entry: after.entries[idx],
      protocol: after,
    });
  } catch (e) {
    console.error("‚ùå Return save error (DB):", e);
    res.status(500).json({ error: "Failed to save return info" });
  }
});

/* ---- PATCH –ø–æ –∑–∞–ø–∏—Å—É –∑ –º–æ–∂–ª–∏–≤–∏–º –ø–µ—Ä–µ–Ω–æ—Å–æ–º –º—ñ–∂ –º—ñ—Å—è—Ü—è–º–∏ ---- */
app.patch("/protocols/:clientId/:month/:index", async (req, res) => {
  try {
    const { clientId, month, index } = req.params;
    const idx = Number(index);

    if (!/^\d{4}-\d{2}$/.test(month)) {
      return res.status(400).json({ error: "Invalid month format" });
    }
    if (!Number.isInteger(idx) || idx < 0) {
      return res.status(400).json({ error: "Invalid index" });
    }

    const body = req.body || {};
    const {
      date,
      comment,
      tools,
      packages,
      shipping,
      delivery,
      returnDate,
      returnTools,
      returnPackages,
      returnDelivery,
      returnShipping,
      courierPlannedDate,
    } = body;

    // –ø–æ—Ç–æ—á–Ω–∏–π –ø—Ä–æ—Ç–æ–∫–æ–ª
    const currentProto = await dbGetProtocolFull(clientId, month);

    const baseExisting = currentProto.entries[idx] || {
      date: date && isISODate(date) ? date : todayLocalISO(),
      tools: [],
      packages: 0,
      shipping: false,
      delivery: null,
      comment: "",
      queue: { courierPending: false, pointPending: false },
    };

    const updated = { ...baseExisting };

    if (typeof date === "string" && isISODate(date)) updated.date = date;
    if (typeof comment === "string") updated.comment = comment;

    if (Array.isArray(tools)) {
      updated.tools = tools
        .filter((t) => t && (t.name || t.nazwa || typeof t === "string"))
        .map((t) =>
          typeof t === "string"
            ? { name: t.trim(), count: 0 }
            : {
                name: String(t.name || t.nazwa || "").trim(),
                count: Number(t.count || t.ilosc || 0) || 0,
              }
        );
    }

    if (packages !== undefined && packages !== null) {
      const p = Number(packages);
      if (!Number.isNaN(p) && Number.isFinite(p)) updated.packages = p;
    }
    if (typeof shipping === "boolean") updated.shipping = !!shipping;

    if (delivery === null || delivery === "") {
      updated.delivery = null;
    } else if (typeof delivery === "string") {
      const d = delivery.trim();
      if (["odbior", "dowoz", "odbior+dowoz"].includes(d)) {
        updated.delivery = d;
      }
    }

    if (typeof returnDate === "string" && isISODate(returnDate)) {
      updated.returnDate = returnDate;
    }
    if (Array.isArray(returnTools)) {
      updated.returnTools = returnTools
        .filter((t) => t && (t.name || t.nazwa || typeof t === "string"))
        .map((t) =>
          typeof t === "string"
            ? { name: t.trim(), count: 0 }
            : {
                name: String(t.name || t.nazwa || "").trim(),
                count: Number(t.count || t.ilosc || 0) || 0,
              }
        );
    }
    if (returnPackages !== undefined && returnPackages !== null) {
      const rp = Number(returnPackages);
      if (!Number.isNaN(rp) && Number.isFinite(rp)) updated.returnPackages = rp;
    }
    if (returnDelivery === null || returnDelivery === "") {
      updated.returnDelivery = null;
    } else if (typeof returnDelivery === "string") {
      const rd = returnDelivery.trim();
      if (["odbior", "dowoz", "odbior+dowoz"].includes(rd)) {
        updated.returnDelivery = rd;
      }
    }
    if (typeof returnShipping === "boolean") {
      updated.returnShipping = !!returnShipping;
    }

    if (typeof courierPlannedDate !== "undefined") {
      updated.queue = updated.queue || {
        courierPending: false,
        pointPending: false,
      };
      if (isISODate(courierPlannedDate)) {
        updated.queue.courierPlannedDate = courierPlannedDate;
      } else {
        delete updated.queue.courierPlannedDate;
      }
    }

    const srcMonth = month;
    const dstMonth =
      (updated.date && ymFromISO(updated.date)) ||
      (baseExisting.date && ymFromISO(baseExisting.date)) ||
      srcMonth;

    const movingToAnotherMonth = dstMonth !== srcMonth;

    if (movingToAnotherMonth) {
      // 1. –≤–∏–¥–∞–ª—è—î–º–æ –∑—ñ —Å—Ç–∞—Ä–æ–≥–æ –º—ñ—Å—è—Ü—è
      await dbDeleteEntryByIndex(clientId, srcMonth, idx);
      // 2. –¥–æ–¥–∞—î–º–æ —É –∫—ñ–Ω–µ—Ü—å –Ω–æ–≤–æ–≥–æ
      const newProtoId = await dbEnsureProtocolHeader(clientId, dstMonth);
      await dbUpsertEntry({
        protocolId: newProtoId,
        index: null,
        newEntry: updated,
      });

      const srcFull = await dbGetProtocolFull(clientId, srcMonth);
      const dstFull = await dbGetProtocolFull(clientId, dstMonth);

      return res.json({
        success: true,
        moved: true,
        from: {
          month: srcMonth,
          index: idx,
          totals: computeMonthlyTotals(srcFull),
        },
        to: {
          month: dstMonth,
          index: dstFull.entries.length - 1,
          totals: computeMonthlyTotals(dstFull),
        },
        entry: updated,
      });
    }

    // –Ω–µ –ø–µ—Ä–µ–Ω–æ—Å–∏–º–æ ‚Üí –∞–ø–¥–µ–π—Ç –ø–æ –º—ñ—Å—Ü—é
    const protocolId = await dbEnsureProtocolHeader(clientId, srcMonth);
    await dbUpsertEntry({
      protocolId,
      index: idx,
      newEntry: updated,
    });

    const after = await dbGetProtocolFull(clientId, srcMonth);

    return res.json({
      success: true,
      moved: false,
      month: srcMonth,
      index: Math.min(idx, after.entries.length - 1),
      entry: after.entries[Math.min(idx, after.entries.length - 1)],
      totals: after.totals,
    });
  } catch (e) {
    console.error("‚ùå Patch entry error (DB):", e);
    res.status(500).json({ error: "Failed to patch protocol entry" });
  }
});

/* ---- –û–¥–∏–Ω –∑–∞–ø–∏—Å –ø—Ä–æ—Ç–æ–∫–æ–ª—É ---- */
app.get("/protocols/:clientId/:month/:index", async (req, res) => {
  try {
    const clientId = decodeURIComponent(req.params.clientId);
    const month = req.params.month;
    const index = Number(req.params.index);
    if (!Number.isInteger(index) || index < 0) {
      return res.status(400).json({ error: "Invalid index" });
    }
    if (!/^\d{4}-\d{2}$/.test(month)) {
      return res.status(400).json({ error: "Invalid month format" });
    }

    const protoFull = await dbGetProtocolFull(clientId, month);
    const entry = protoFull.entries[index] || null;

    return res.json({
      id: clientId,
      month,
      index,
      entry,
      totals: protoFull.totals,
    });
  } catch (e) {
    console.error("‚ùå Error reading single protocol entry (DB):", e);
    res.status(500).json({ error: "Failed to load protocol entry" });
  }
});

/* ---- BULK –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –¥–∞—Ç –ø–æ–≤–µ—Ä–Ω–µ–Ω–Ω—è ---- */
app.post("/protocols/:clientId/:month/return/bulk", async (req, res) => {
  try {
    const { clientId, month } = req.params;
    const { indices, returnDate } = req.body || {};
    if (!Array.isArray(indices) || !indices.length) {
      return res
        .status(400)
        .json({ error: "indices must be a non-empty array" });
    }
    if (
      typeof returnDate !== "string" ||
      !/^\d{4}-\d{2}-\d{2}$/.test(returnDate)
    ) {
      return res.status(400).json({ error: "Invalid returnDate" });
    }

    const protoFull = await dbGetProtocolFull(clientId, month);

    for (const i of indices) {
      const idx = Number(i);
      if (!Number.isInteger(idx)) continue;
      if (!protoFull.entries[idx]) continue;
      protoFull.entries[idx].returnDate = returnDate;

      const protocolId = await dbEnsureProtocolHeader(clientId, month);
      await dbUpsertEntry({
        protocolId,
        index: idx,
        newEntry: protoFull.entries[idx],
      });
    }

    const after = await dbGetProtocolFull(clientId, month);
    res.json({ success: true, protocol: after });
  } catch (e) {
    console.error("‚ùå Bulk returnDate update error (DB):", e);
    res.status(500).json({ error: "Failed to bulk update returnDate" });
  }
});

/* ---- summarize –ø—Ä–æ—Ç–æ–∫–æ–ª—É (–º—ñ—Å—è—Ü—è) ---- */
app.post("/protocols/:clientId/:month/summarize", async (req, res) => {
  try {
    const { clientId, month } = req.params;
    const { summarized } = req.body || {};
    if (!/^\d{4}-\d{2}$/.test(month)) {
      return res.status(400).json({ error: "Invalid month format" });
    }

    await dbSetSummarized(clientId, month, !!summarized);
    const after = await dbGetProtocolFull(clientId, month);

    res.json({ success: true, protocol: after });
  } catch (e) {
    console.error("‚ùå summarize protocol error (DB):", e);
    res.status(500).json({ error: "Failed to summarize/unsummarize" });
  }
});

/* -----------------------------------------------------------
 * SIGN QUEUE API (DB)
 * ----------------------------------------------------------- */
app.get("/sign-queue", async (req, res) => {
  try {
    const type = String(req.query.type || "").toLowerCase();
    if (!["courier", "point"].includes(type)) {
      return res
        .status(400)
        .json({ error: "type must be 'courier' or 'point'" });
    }

    const monthFilter =
      typeof req.query.month === "string" &&
      /^\d{4}-\d{2}$/.test(req.query.month)
        ? req.query.month
        : null;
    const dayFilter =
      typeof req.query.date === "string" &&
      /^\d{4}-\d{2}-\d{2}$/.test(req.query.date)
        ? req.query.date
        : null;

    let items = [];

    // 1) —Ç—ñ–ª—å–∫–∏ –ë–î
    const listLite = await dbListProtocolsWithEntriesLite();

    const clientsIdx = await dbGetAllClientsIndex();
    for (const p of listLite) {
      if (monthFilter && p.month !== monthFilter) continue;
      const full = await dbGetProtocolFull(p.id, p.month);
      full.entries.forEach((e, i) => {
        const q = e.queue || {};
        const pending =
          type === "courier" ? !!q.courierPending : !!q.pointPending;
        if (!pending) return;

        if (type === "courier") {
          const planned =
            typeof q.courierPlannedDate === "string" &&
            /^\d{4}-\d{2}-\d{2}$/.test(q.courierPlannedDate)
              ? q.courierPlannedDate
              : null;
          if (dayFilter && planned && planned > dayFilter) return;
        }

        items.push({
          clientId: full.id,
          clientName: clientsIdx[full.id]?.name || full.id,
          month: full.month,
          index: i,
          date: e.date || null,
          returnDate: e.returnDate || null,
          tools: Array.isArray(e.tools) ? e.tools : [],
          packages: Number(e.packages || 0) || 0,
          delivery: e.delivery || null,
          shipping: !!e.shipping,
          comment: e.comment || "",
          signatures: e.signatures || {},
          queue: {
            ...(e.queue || {}),
            courierPlannedDate: (e.queue || {}).courierPlannedDate || null,
          },
        });
      });
    }
    return res.json({ items });
  } catch (e) {
    console.error("‚ùå /sign-queue error:", e);
    res.status(500).json({ error: "Failed to load sign queue" });
  }
});

/* -----------------------------
 * EXPORT .EPP (InsERT GT/Nexo)
 * ----------------------------- */
app.post("/export-epp", async (req, res) => {
  try {
    const { files } = req.body || {};
    const allRows = await invoicesRepo.queryAllInvoices();
    const all = allRows.map(mapDbInvoiceRow);

    const selected =
      Array.isArray(files) && files.length
        ? all.filter(
            (i) => files.includes(i.filename) || files.includes(i.number)
          )
        : all;

    const buf = generateEPPBuffer(selected);
    res.setHeader("Content-Type", "application/octet-stream");
    res.setHeader("Content-Disposition", 'attachment; filename="export.epp"');
    res.setHeader("Content-Transfer-Encoding", "binary");
    res.setHeader("Content-Length", buf.length);
    return res.end(buf);
  } catch (e) {
    console.error("EPP export DB error:", e);
    return res.status(500).json({ error: "B≈ÇƒÖd eksportu EPP" });
  }
});

/* -----------------------------
 * START
 * ----------------------------- */
const PORT = process.env.PORT || 3000;

// peek counts
// peek counts (SQL helper)
app.get("/__peek", async (req, res) => {
  try {
    const inv = await sql(`SELECT COUNT(*) AS c FROM invoices`);
    const d = await sql(`SELECT COUNT(*) AS c FROM psl_drafts`);
    const s = await sql(`SELECT COUNT(*) AS c FROM psl_saved`);
    res.json({
      invoices: inv[0]?.c || 0,
      pslDrafts: d[0]?.c || 0,
      pslSaved: s[0]?.c || 0,
    });
  } catch (e) {
    console.error(e);
    res.status(500).json({ error: String(e.message) });
  }
});

// DEBUG: –ø—Ä–æ—Ç–æ–∫–æ–ª–∏ ‚Äî –∫–æ—Ä–æ—Ç–∫–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –≤–º—ñ—Å—Ç—É –ë–î
app.get("/__db/check-protocols", async (_req, res) => {
  try {
    const pcRows = await sql(`SELECT COUNT(*) AS c FROM protocols`);
    const ecRows = await sql(`SELECT COUNT(*) AS c FROM protocol_entries`);
    const pc = pcRows[0];
    const ec = ecRows[0];

    const protoHeads = await sql(`
      SELECT id AS protocolId, clientId, month, summarized, createdAt, updatedAt
      FROM protocols
      ORDER BY month DESC, clientId ASC
      LIMIT 20
    `);

    const latestEntries = await sql(`
      SELECT id, protocol_id AS protocolId, date, packages, delivery, shipping
      FROM protocol_entries
      ORDER BY id DESC
      LIMIT 20
    `);

    const joinAgg = await sql(`
      SELECT p.id AS protocolId, p.clientId, p.month, COUNT(e.id) AS entries
      FROM protocols p
      LEFT JOIN protocol_entries e ON e.protocol_id = p.id
      GROUP BY p.id, p.clientId, p.month
      ORDER BY p.month DESC, p.clientId ASC
      LIMIT 100
    `);

    res.json({
      counts: { protocols: pc.c, entries: ec.c },
      heads: protoHeads,
      latestEntries,
      byProtocol: joinAgg,
    });
  } catch (e) {
    console.error("DEBUG /__db/check-protocols", e);
    res.status(500).json({ error: String(e.message) });
  }
});

// DEBUG: –ø–æ–∫–∞–∑–∞—Ç–∏ –ø–æ–≤–Ω–∏–π –ø—Ä–æ—Ç–æ–∫–æ–ª, —è–∫ –π–æ–≥–æ –±–∞—á–∏—Ç—å –±–µ–∫–µ–Ω–¥
app.get("/__db/protocol-full/:clientId/:month", async (req, res) => {
  try {
    const clientId = decodeURIComponent(req.params.clientId);
    const month = req.params.month;
    const data = await dbGetProtocolFull(clientId, month);
    res.json(data);
  } catch (e) {
    console.error("DEBUG /__db/protocol-full", e);
    res.status(500).json({ error: String(e.message) });
  }
});
app.use((err, _req, res, _next) => {
  console.error("‚ùå Unhandled express error:", err);
  if (!res.headersSent)
    res.status(500).json({ error: "Internal server error" });
});

// -----------------------------
// FRONTEND STATIC + SPA FALLBACK
// -----------------------------
(() => {
  const FRONT_DIR_CANDIDATES = [
    path.join(__dirname, "dist"),
    path.join(__dirname, "frontend", "dist"),
    path.join(process.cwd(), "dist"),
    path.join(process.cwd(), "frontend", "dist"),
  ];
  const FRONT_DIR = FRONT_DIR_CANDIDATES.find((p) => fs.existsSync(p));

  const API_PREFIXES = [
    "/psl",
    "/analytics",
    "/upload",
    "/gen",
    "/generated",
    "/signatures",
    "/services",
    "/settings",
    "/clients",
    "/invoices",
    "/saved-invoices",
    "/save-invoices",
    "/download-invoice",
    "/download-multiple",
    "/protocols",
    "/export-epp",
    "/__",
  ];

  if (FRONT_DIR) {
    app.use(express.static(FRONT_DIR, { fallthrough: true }));

    // SPA fallback –±–µ–∑ '*': –∑–∞–≥–∞–ª—å–Ω–∏–π middleware
    app.use((req, res, next) => {
      if (req.method !== "GET") return next();
      if (API_PREFIXES.some((p) => req.path.startsWith(p))) return next();
      res.sendFile(path.join(FRONT_DIR, "index.html"));
    });

    console.log("üß© Serving frontend from:", FRONT_DIR);
  } else {
    console.log();

    // dev —Ä–µ–¥—ñ—Ä–µ–∫—Ç –Ω–∞ Vite –±–µ–∑ '*'
    app.use((req, res, next) => {
      if (req.method !== "GET") return next();
      if (API_PREFIXES.some((p) => req.path.startsWith(p))) return next();
    });
  }
})();
initDB().catch((e) => {
  console.error("initDB failed:", e);
  process.exit(1);
});

app.post("/api/invoices/pdf-list", createInvoiceListPDF);

app.listen(PORT, () =>
  console.log(`‚úÖ Backend running on http://localhost:${PORT}`)
);
